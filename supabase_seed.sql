-- ============================
-- Supabase seed (v3) — Auth + Roles + Usuarios (unificado)
-- ============================

-- 0) Extensiones
create extension if not exists "pgcrypto";

-- 1) Catálogo de roles
create table if not exists public.roles (
  id smallserial primary key,
  nombre text not null unique check (nombre in ('admin','contador','operador','socio')),
  descripcion text
);

-- Seed de roles (idempotente)
insert into public.roles (nombre, descripcion) values
  ('admin','Acceso total a la plataforma'),
  ('contador','Acceso a reportes y pagos'),
  ('operador','Gestión operativa de cuotas y pagos'),
  ('socio','Usuario jugador/socio del club')
on conflict (nombre) do nothing;

-- 2) Usuarios (1:1 con auth.users)
--    - id = auth.users.id
--    - documento único (una persona = un documento)
create table if not exists public.usuarios (
  id uuid primary key references auth.users(id) on delete cascade,
  documento text not null unique,
  email text not null unique,
  nombre text not null,
  telefono text,
  rol_id smallint not null references public.roles(id),
  activo boolean not null default true,
  creado_en timestamptz not null default now(),
  actualizado_en timestamptz not null default now()
);

create index if not exists usuarios_rol_idx on public.usuarios (rol_id);

-- 3) Períodos
create table if not exists public.periodos (
  id uuid primary key default gen_random_uuid(),
  mes smallint not null check (mes between 1 and 12),
  anio integer not null,
  importe numeric(10,2) not null,
  creado_en timestamptz not null default now(),
  unique (mes, anio)
);

-- 4) Cuotas por usuario (antes: cuotas_socios)
create table if not exists public.cuotas_usuarios (
  id uuid primary key default gen_random_uuid(),
  usuario_id uuid not null references public.usuarios(id) on delete cascade,
  periodo_id uuid not null references public.periodos(id) on delete cascade,
  periodo text, -- YYYY-MM (se autocompleta con trigger)
  importe numeric(10,2) not null,
  estado text not null default 'pendiente' check (estado in ('pendiente', 'pagado', 'vencido', 'rechazado')),
  vencimiento date,
  creado_en timestamptz not null default now(),
  unique (usuario_id, periodo_id)
);

create index if not exists cuotas_usuarios_usuario_idx on public.cuotas_usuarios (usuario_id);
create index if not exists cuotas_usuarios_estado_idx  on public.cuotas_usuarios (estado);

-- 5) Pagos (antes: socio_id)
create table if not exists public.pagos (
  id uuid primary key default gen_random_uuid(),
  usuario_id uuid not null references public.usuarios(id) on delete cascade,
  periodo_id uuid references public.periodos(id) on delete set null,
  periodo text,
  monto numeric(10,2) not null,
  metodo text not null default 'manual', -- 'manual' | 'mp' | 'transferencia'
  referencia text unique,                        -- ej: mp_payment_id (único para integraciones)
  creado_en timestamptz not null default now()
);

create unique index if not exists pagos_ref_uniq on public.pagos (referencia);
create index if not exists pagos_usuario_idx on public.pagos (usuario_id);
create index if not exists pagos_creado_en_idx on public.pagos (creado_en);

-- 6) Auditoría (actor = usuarios.id = auth.users.id)
create table if not exists public.auditoria (
  id bigint generated by default as identity primary key,
  actor uuid references public.usuarios(id),
  accion text not null,
  entidad text not null,
  entidad_id uuid,
  datos jsonb,
  creado_en timestamptz not null default now()
);

-- 7) Helper periodo YYYY-MM
create or replace function public.set_periodo_text()
returns trigger as $$
begin
  if new.periodo_id is not null then
    select concat(p.anio, '-', lpad(p.mes::text, 2, '0'))
      into new.periodo
    from public.periodos p
    where p.id = new.periodo_id;
  else
    new.periodo := null;
  end if;
  return new;
end;
$$ language plpgsql;

drop trigger if exists cuotas_periodo_text on public.cuotas_usuarios;
create trigger cuotas_periodo_text
before insert or update on public.cuotas_usuarios
for each row execute function public.set_periodo_text();

drop trigger if exists pagos_periodo_text on public.pagos;
create trigger pagos_periodo_text
before insert or update on public.pagos
for each row execute function public.set_periodo_text();

-- 8) Stats + vista de reportes (simple, sin realtime en views)
create or replace function public.dashboard_stats()
returns table (usuarios integer, morosos integer, pagos integer)
as $$
  select
    (select count(*) from public.usuarios where activo = true)::integer as usuarios,
    (select count(*) from public.cuotas_usuarios where estado = 'vencido')::integer as morosos,
    (select count(*) from public.pagos
       where creado_en >= date_trunc('month', now())
         and creado_en <  (date_trunc('month', now()) + interval '1 month'))::integer as pagos;
$$ language sql stable;

create or replace view public.reportes_view as
select 'Usuarios activos'::text as label, count(*)::numeric as value
  from public.usuarios where activo = true
union all
select 'Morosos'::text, count(*)::numeric
  from public.cuotas_usuarios where estado = 'vencido'
union all
select 'Pagos del mes'::text, count(*)::numeric
  from public.pagos
  where creado_en >= date_trunc('month', now())
    and creado_en <  (date_trunc('month', now()) + interval '1 month');

-- 9) Realtime publication (solo tablas)
-- Reemplazamos ALTER PUBLICATION directo por un bloque idempotente
do $$
begin
  -- crear la publicación si no existe
  if not exists (select 1 from pg_publication where pubname = 'supabase_realtime') then
    execute 'create publication supabase_realtime';
  end if;

  -- helper para añadir si no existe en la publicación
  if not exists (
    select 1
    from pg_publication_tables
    where pubname = 'supabase_realtime' and schemaname = 'public' and tablename = 'usuarios'
  ) then
    execute 'alter publication supabase_realtime add table public.usuarios';
  end if;

  if not exists (
    select 1
    from pg_publication_tables
    where pubname = 'supabase_realtime' and schemaname = 'public' and tablename = 'roles'
  ) then
    execute 'alter publication supabase_realtime add table public.roles';
  end if;

  if not exists (
    select 1
    from pg_publication_tables
    where pubname = 'supabase_realtime' and schemaname = 'public' and tablename = 'periodos'
  ) then
    execute 'alter publication supabase_realtime add table public.periodos';
  end if;

  if not exists (
    select 1
    from pg_publication_tables
    where pubname = 'supabase_realtime' and schemaname = 'public' and tablename = 'cuotas_usuarios'
  ) then
    execute 'alter publication supabase_realtime add table public.cuotas_usuarios';
  end if;

  if not exists (
    select 1
    from pg_publication_tables
    where pubname = 'supabase_realtime' and schemaname = 'public' and tablename = 'pagos'
  ) then
    execute 'alter publication supabase_realtime add table public.pagos';
  end if;
end$$;
-- (no agregar vistas)

-- 10) RLS
alter table public.roles           enable row level security;
alter table public.usuarios        enable row level security;
alter table public.periodos        enable row level security;
alter table public.cuotas_usuarios enable row level security;
alter table public.pagos           enable row level security;
alter table public.auditoria       enable row level security;

-- Limpieza idempotente
do $$
begin
  perform 1;
  -- roles
  execute 'drop policy if exists roles_read_all on public.roles';
  -- usuarios
  execute 'drop policy if exists usuarios_select_self on public.usuarios';
  execute 'drop policy if exists usuarios_update_self on public.usuarios';
  execute 'drop policy if exists usuarios_select_admin on public.usuarios';
  execute 'drop policy if exists usuarios_insert_admin on public.usuarios';
  execute 'drop policy if exists usuarios_update_admin on public.usuarios';
  -- periodos
  execute 'drop policy if exists periodos_select_auth on public.periodos';
  execute 'drop policy if exists periodos_insert_admin on public.periodos';
  execute 'drop policy if exists periodos_update_admin on public.periodos';
  -- cuotas_usuarios
  execute 'drop policy if exists cuotas_read_self_or_admin on public.cuotas_usuarios';
  execute 'drop policy if exists cuotas_insert_admin on public.cuotas_usuarios';
  execute 'drop policy if exists cuotas_update_admin on public.cuotas_usuarios';
  -- pagos
  execute 'drop policy if exists pagos_read_self_or_admin on public.pagos';
  execute 'drop policy if exists pagos_insert_self_or_admin on public.pagos';
  execute 'drop policy if exists pagos_update_admin on public.pagos';
  -- auditoria
  execute 'drop policy if exists auditoria_admin on public.auditoria';
exception when others then null;
end$$;

-- roles: lectura para autenticados (metadatos inofensivos)
create policy roles_read_all
on public.roles for select
to authenticated
using (true);

-- usuarios: el usuario ve/actualiza su propio registro; roles elevados ven todos
create policy usuarios_select_self
on public.usuarios for select
to authenticated
using (id = auth.uid());

create policy usuarios_update_self
on public.usuarios for update
to authenticated
using (id = auth.uid())
with check (id = auth.uid());

create policy usuarios_select_admin
on public.usuarios for select
to authenticated
using (
  exists (
    select 1
    from public.usuarios u
    join public.roles r on r.id = u.rol_id
    where u.id = auth.uid()
      and r.nombre in ('admin','contador','operador')
  )
);

create policy usuarios_insert_admin
on public.usuarios for insert
to authenticated
with check (
  exists (
    select 1
    from public.usuarios u
    join public.roles r on r.id = u.rol_id
    where u.id = auth.uid()
      and r.nombre = 'admin'
  )
);

create policy usuarios_update_admin
on public.usuarios for update
to authenticated
using (
  exists (
    select 1
    from public.usuarios u
    join public.roles r on r.id = u.rol_id
    where u.id = auth.uid()
      and r.nombre = 'admin'
  )
);

-- periodos: lectura para autenticados; insert/update para admin
create policy periodos_select_auth
on public.periodos for select
to authenticated
using (true);

create policy periodos_insert_admin
on public.periodos for insert
to authenticated
with check (
  exists (
    select 1
    from public.usuarios u
    join public.roles r on r.id = u.rol_id
    where u.id = auth.uid()
      and r.nombre = 'admin'
  )
);

create policy periodos_update_admin
on public.periodos for update
to authenticated
using (
  exists (
    select 1
    from public.usuarios u
    join public.roles r on r.id = u.rol_id
    where u.id = auth.uid()
      and r.nombre = 'admin'
  )
);

-- cuotas_usuarios: propio o admin/contador/operador
create policy cuotas_read_self_or_admin
on public.cuotas_usuarios for select
to authenticated
using (
  usuario_id = auth.uid()
  or exists (
    select 1
    from public.usuarios u
    join public.roles r on r.id = u.rol_id
    where u.id = auth.uid()
      and r.nombre in ('admin','contador','operador')
  )
);

create policy cuotas_insert_admin
on public.cuotas_usuarios for insert
to authenticated
with check (
  exists (
    select 1
    from public.usuarios u
    join public.roles r on r.id = u.rol_id
    where u.id = auth.uid()
      and r.nombre in ('admin','contador','operador')
  )
);

create policy cuotas_update_admin
on public.cuotas_usuarios for update
to authenticated
using (
  exists (
    select 1
    from public.usuarios u
    join public.roles r on r.id = u.rol_id
    where u.id = auth.uid()
      and r.nombre in ('admin','contador','operador')
  )
);

-- pagos: propio o admin/contador/operador
create policy pagos_read_self_or_admin
on public.pagos for select
to authenticated
using (
  usuario_id = auth.uid()
  or exists (
    select 1
    from public.usuarios u
    join public.roles r on r.id = u.rol_id
    where u.id = auth.uid()
      and r.nombre in ('admin','contador','operador')
  )
);

create policy pagos_insert_self_or_admin
on public.pagos for insert
to authenticated
with check (
  usuario_id = auth.uid()
  or exists (
    select 1
    from public.usuarios u
    join public.roles r on r.id = u.rol_id
    where u.id = auth.uid()
      and r.nombre in ('admin','contador','operador')
  )
);

create policy pagos_update_admin
on public.pagos for update
to authenticated
using (
  exists (
    select 1
    from public.usuarios u
    join public.roles r on r.id = u.rol_id
    where u.id = auth.uid()
      and r.nombre = 'admin'
  )
);

-- auditoria: solo roles elevados
create policy auditoria_admin
on public.auditoria for select
to authenticated
using (
  exists (
    select 1
    from public.usuarios u
    join public.roles r on r.id = u.rol_id
    where u.id = auth.uid()
      and r.nombre in ('admin','contador','operador')
  )
);

-- 11) Seed mínimo (periodos)
insert into public.periodos (mes, anio, importe) values
  (extract(month from now())::int, extract(year from now())::int, 15000),
  ((extract(month from now())::int % 12) + 1,
   extract(year from now())::int + case when extract(month from now())::int = 12 then 1 else 0 end,
   15000)
on conflict do nothing;
/*
-- 12) RPC helper: crear/actualizar usuario (servicio backend debe llamarla usando SERVICE ROLE key)
   - Seguridad: SECURITY DEFINER y search_path para que el rol que crea la función (ej. postgres) controle permisos
   - Comportamiento:
     * Valida que el auth.users.id exista.
     * Valida que documento/email no estén usados por otro id.
     * Inserta o actualiza la fila en public.usuarios con id = auth users id.
     * Retorna la fila de public.usuarios.
*/
create or replace function public.create_usuario(
  p_id uuid,
  p_documento text,
  p_email text,
  p_nombre text,
  p_telefono text default null,
  p_rol_nombre text default 'socio'
)
returns public.usuarios
language plpgsql
security definer
set search_path = public, auth
as $$
declare
  v_role_id smallint;
  v_conflict_id uuid;
  v_exists_auth boolean;
  v_result public.usuarios%rowtype;
begin
  -- check auth user exists
  select exists(select 1 from auth.users where id = p_id) into v_exists_auth;
  if not v_exists_auth then
    raise exception 'auth.users id % no existe', p_id;
  end if;

  -- get role id
  select id into v_role_id from public.roles where nombre = p_rol_nombre;
  if v_role_id is null then
    raise exception 'Rol % no encontrado', p_rol_nombre;
  end if;

  -- ensure documento/email not used by other usuario
  select id into v_conflict_id
    from public.usuarios
   where (documento = p_documento or email = p_email)
     and id IS DISTINCT FROM p_id
   limit 1;

  if v_conflict_id is not null then
    raise exception 'Documento o email ya asociado a otro usuario: %', v_conflict_id;
  end if;

  -- upsert by id (id = auth.users.id)
  insert into public.usuarios (id, documento, email, nombre, telefono, rol_id, activo, creado_en, actualizado_en)
  values (p_id, p_documento, p_email, p_nombre, p_telefono, v_role_id, true, now(), now())
  on conflict (id) do
    update set documento = excluded.documento,
               email = excluded.email,
               nombre = excluded.nombre,
               telefono = excluded.telefono,
               rol_id = excluded.rol_id,
               actualizado_en = now()
  returning * into v_result;

  return v_result;
end;
$$;

-- Note: esta RPC está disponible para uso backend (SERVICE_ROLE) si lo necesitás.
-- Sin embargo, con el trigger automático siguiente, generalmente no será necesaria.

-- 13) Trigger automático: auth.users -> public.usuarios (1:1)
-- Cuando se crea un usuario en auth.users, automáticamente se crea en public.usuarios
-- usando los datos de raw_user_meta_data enviados desde el frontend durante signUp.

create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer
set search_path = public, auth
as $$
declare
  v_rol_id smallint;
  v_rol_nombre text;
  v_documento text;
  v_nombre text;
  v_telefono text;
begin
  -- Extraer metadata del signup (enviada desde el frontend)
  v_documento := coalesce(new.raw_user_meta_data->>'documento', '');
  v_nombre := coalesce(new.raw_user_meta_data->>'nombre', new.email);
  v_telefono := new.raw_user_meta_data->>'telefono';
  v_rol_nombre := coalesce(new.raw_user_meta_data->>'rol', 'socio');

  -- Validar que documento no esté vacío
  if v_documento = '' then
    raise exception 'El documento es obligatorio en raw_user_meta_data';
  end if;

  -- Obtener rol_id
  select id into v_rol_id 
  from public.roles 
  where nombre = v_rol_nombre;
  
  if v_rol_id is null then
    -- Si el rol no existe, usar 'socio' por defecto
    select id into v_rol_id 
    from public.roles 
    where nombre = 'socio';
  end if;

  -- Insertar en public.usuarios (1:1 con auth.users)
  insert into public.usuarios (
    id, 
    documento, 
    email, 
    nombre, 
    telefono, 
    rol_id, 
    activo, 
    creado_en, 
    actualizado_en
  )
  values (
    new.id,
    v_documento,
    new.email,
    v_nombre,
    v_telefono,
    v_rol_id,
    true,
    now(),
    now()
  );

  return new;
exception
  when unique_violation then
    -- Si el documento ya existe, loguear pero no fallar el signup de auth
    raise warning 'Documento % ya existe para otro usuario', v_documento;
    return new;
  when others then
    -- Otros errores: loguear y continuar
    raise warning 'Error creando usuario en public.usuarios: %', sqlerrm;
    return new;
end;
$$;

-- Crear el trigger en auth.users (requiere permisos de superuser/supabase)
drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute function public.handle_new_user();

-- NOTA: Flujo de registro desde el frontend:
-- 1) El cliente llama a supabase.auth.signUp() enviando:
--    {
--      email: 'usuario@example.com',
--      password: 'password123',
--      options: {
--        data: {
--          documento: '12345678',
--          nombre: 'Juan Pérez',
--          telefono: '+5491123456789',
--          rol: 'socio' // opcional, default: 'socio'
--        }
--      }
--    }
-- 2) Supabase crea el usuario en auth.users
-- 3) El trigger automáticamente crea el registro en public.usuarios
-- 4) El usuario ya está listo para usar la aplicación

-- (Limpieza rápida de políticas con nombres antiguos/duplicados)
drop policy if exists usuarios_select_self on public.usuarios;
drop policy if exists usuarios_update_self on public.usuarios;
drop policy if exists usuarios_select_admin on public.usuarios;
drop policy if exists usuarios_insert_admin on public.usuarios;
drop policy if exists usuarios_update_admin on public.usuarios;
